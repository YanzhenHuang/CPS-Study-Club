# 手寫軟光柵2
這次嘗試加入一些三維物體

[參考網址](https://raytracing.github.io/books/RayTracingInOneWeekend.html)

# 前情提要 ~~(水字數)~~
 
## 球是甚麼?

$$
x^2 + y^2 + z^2 =
R^2
$$

## 如何判斷一個點是否在球內部?

### 如果球的球心座標為 $(0,0,0)$ :

$$
內部: x^2 + y^2 + z^2 <
R^2
$$

$$
外部: x^2 + y^2 + z^2 >
R^2
$$

$$
表面: x^2 + y^2 + z^2 =
R^2
$$

### 如果球的球心座標為 $(C_x,C_y,C_z)$ :

$$
(x-C_x)^2 + (y-C_y)^2 + (z-C_z)^2 < R^2
$$

## 如果點是用向量的形式表示呢?

$$
\mathbf{P} = (x,y,z) 
$$

$$
(\mathbf{P} - \mathbf{C}) \cdot (\mathbf{P} - \mathbf{C})
     = (x - C_x)^2 + (y - C_y)^2 + (z - C_z)^2
$$

$$
(\mathbf{P} - \mathbf{C}) \cdot (\mathbf{P} - \mathbf{C}) = R^2
$$

# 第一步: 數學
現在有一個需求: 

> 我們有一條射線和一個球體，求它們是否相交? 如果它們相交，那麼它們相交的點又在哪裡?

首先先設射線 $\mathbf{P}(t)$ 方程， 其中 $\mathbf{A} + t\mathbf{b}$ 為直線方程參數， $t$ 則代表需要求解相交的點

$$
\mathbf{P}(t) = \mathbf{A} + t\mathbf{b}
$$

再代入到剛剛上面的式子

$$
(\mathbf{P}(t) - \mathbf{C}) \cdot (\mathbf{P}(t) - \mathbf{C}) = r^2
$$

拆開 $\mathbf{P}(t)$ 方程:

$$
(\mathbf{A} + t \mathbf{b} - \mathbf{C})
      \cdot (\mathbf{A} + t \mathbf{b} - \mathbf{C}) = r^2
$$

$$
t^2 \mathbf{b} \cdot \mathbf{b}
     + 2t \mathbf{b} \cdot (\mathbf{A}-\mathbf{C})
     + (\mathbf{A}-\mathbf{C}) \cdot (\mathbf{A}-\mathbf{C}) - r^2 = 0
$$

$t$ 有三種可能:
- 不相交
- 相交一個點
- 相交兩個點

![](pic/fig-1.04-ray-sphere.jpg)

那麼我們就可以開始模擬一個球體了，先寫一個hit_sphere()函數，返回值為與當前射線是否相交。在ray_color()函數中，如果射線相交了，則放上一顆紅色像素點

```c++
bool hit_sphere(const point3& center, double radius, const ray& r) {
    vec3 oc = r.origin() - center;
    auto a = dot(r.direction(), r.direction());
    auto b = 2.0 * dot(oc, r.direction());
    auto c = dot(oc, oc) - radius*radius;
    auto discriminant = b*b - 4*a*c;
    return (discriminant > 0);
}

color ray_color(const ray& r) {
    // 球在在(0,0,-1)的位置，相交了，則放上一顆紅色像素點
    if (hit_sphere(point3(0,0,-1), 0.5, r))
        return color(1, 0, 0);
    
    vec3 unit_direction = unit_vector(r.direction());
    auto t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*color(1.0, 1.0, 1.0) + t*color(0.5, 0.7, 1.0);
}
```

