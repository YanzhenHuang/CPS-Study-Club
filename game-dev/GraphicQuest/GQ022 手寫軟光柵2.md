# 手寫軟光柵2
這次嘗試加入一些三維物體

[參考網址](https://raytracing.github.io/books/RayTracingInOneWeekend.html)

# 前情提要 ~~(水字數)~~
 
## 球是甚麼?

$$
x^2 + y^2 + z^2 =
R^2
$$

## 如何判斷一個點是否在球內部?

### 如果球的球心座標為 $(0,0,0)$ :

$$
內部: x^2 + y^2 + z^2 <
R^2
$$

$$
外部: x^2 + y^2 + z^2 >
R^2
$$

$$
表面: x^2 + y^2 + z^2 =
R^2
$$

### 如果球的球心座標為 $(C_x,C_y,C_z)$ :

$$
(x-C_x)^2 + (y-C_y)^2 + (z-C_z)^2 < R^2
$$

## 如果點是用向量的形式表示呢?

$$
\mathbf{P} = (x,y,z) 
$$

$$
(\mathbf{P} - \mathbf{C}) \cdot (\mathbf{P} - \mathbf{C})
     = (x - C_x)^2 + (y - C_y)^2 + (z - C_z)^2
$$

$$
(\mathbf{P} - \mathbf{C}) \cdot (\mathbf{P} - \mathbf{C}) = R^2
$$

# 第一步: 數學
現在有一個需求: 

> 我們有一條射線和一個球體，求它們是否相交? 如果它們相交，那麼它們相交的點又在哪裡?

首先先設射線 $\mathbf{P}(t)$ 方程， 其中 $\mathbf{A} + t\mathbf{b}$ 為直線方程參數， $t$ 則代表需要求解相交的點

$$
\mathbf{P}(t) = \mathbf{A} + t\mathbf{b}
$$

再代入到剛剛上面的式子

$$
(\mathbf{P}(t) - \mathbf{C}) \cdot (\mathbf{P}(t) - \mathbf{C}) = r^2
$$

拆開 $\mathbf{P}(t)$ 方程:

$$
(\mathbf{A} + t \mathbf{b} - \mathbf{C})
      \cdot (\mathbf{A} + t \mathbf{b} - \mathbf{C}) = r^2
$$

$$
t^2 \mathbf{b} \cdot \mathbf{b}
     + 2t \mathbf{b} \cdot (\mathbf{A}-\mathbf{C})
     + (\mathbf{A}-\mathbf{C}) \cdot (\mathbf{A}-\mathbf{C}) - r^2 = 0
$$

$t$ 有三種可能:
- 不相交
- 相交一個點
- 相交兩個點

![](pic/fig-1.04-ray-sphere.jpg)

那麼我們就可以開始模擬一個球體了，先寫一個hit_sphere()函數，返回值為與當前射線是否相交。在ray_color()函數中，如果射線相交了，則放上一顆紅色像素點

```c++
bool hit_sphere(const point3& center, double radius, const ray& r) {
    vec3 oc = r.origin() - center;
    auto a = dot(r.direction(), r.direction());
    auto b = 2.0 * dot(oc, r.direction());
    auto c = dot(oc, oc) - radius*radius;
    auto discriminant = b*b - 4*a*c;
    return (discriminant > 0);
}

color ray_color(const ray& r) {
    // 球在在(0,0,-1)的位置，相交了，則放上一顆紅色像素點
    if (hit_sphere(point3(0,0,-1), 0.5, r))
        return color(1, 0, 0);
    
    vec3 unit_direction = unit_vector(r.direction());
    auto t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*color(1.0, 1.0, 1.0) + t*color(0.5, 0.7, 1.0);
}
```

完成基本的著色

![](pic/redball.png)

# 第二步: 表面法線和更多物體

表面法線是垂直於該平面的三維向量。

曲面在某點P處的法線為垂直於該點切平面（tangent plane）的向量

![](pic/300px-Surface_normals.svg.png)

那麼如果我們想要求球面的法向量呢? 很簡單，只要P點減去球心C就是法向量了

![](pic/fig-1.05-sphere-normal.jpg)

```c++
// 重新改寫 return double
double hit_sphere(const point3& center, double radius, const ray& r)
{
	vec3 oc = r.origin() - center;
	auto a = dot(r.direction(), r.direction());
	auto b = 2.0 * dot(oc, r.direction());
	auto c = dot(oc, oc) - radius * radius;
	auto discriminant = b * b - 4 * a * c;
	if (discriminant < 0) {
		return -1.0;
	}
	else {
		// 尋根公式
		return (-b - sqrt(discriminant)) / (2.0 * a);
	}
}

color ray_color(const ray& r)
{
	// t 為hit_sphere()返回值
	auto t = hit_sphere(point3(0, 0, -1), 0.5, r);
	if (t > 0.0) {
		// 我們還沒有任何燈光或任何東西，所以讓我們用彩色貼圖可視化法線。
		// 這裡提供了一個可視化法線的常用技巧，就是單位長度向量
		// 因為它很容易假設並且直觀————每個分量都在 -1 和 +1 之間
		// 其實這裡就是將每個分量映射到 0 到 1 的區間，
		// 然後將 x / y / z 映射到 r / g / b
		vec3 N = unit_vector(r.at(t) - vec3(0, 0, -1));
		return 0.5 * color(N.x() + 1, N.y() + 1, N.z() + 1);
	}
	vec3 unit_direction = unit_vector(r.direction());
	t = 0.5 * (unit_direction.y() + 1.0);
	return (1.0 - t) * color(1.0, 1.0, 1.0) + t * color(0.5, 0.7, 1.0);
}
```

![](pic/renderedball.png)

