# GQ001 紋理(材質)的構成

紋理(材質)是甚麼?本質上就是一張圖片

![](pic/lion.png)

一種可以讓著色器讀寫的結構化存取形式
```
Image [Height] [Width] [4]
T [512][512][4]
RGBA
```

# 紋理管線 (通常使用的架構)

1. 模型空間位置 -> 投影函數

2. 紋理映射 -> 紋理座標 (UV座標)

3. 通訊函數 -> 新紋理座標

4. 紋理採樣 (Sampler, 避免依賴紋理讀取) -> 紋理值

![](pic/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202022-08-27%20001814.png)

# UV值，UV座標
對於三維模型，有兩個最重要的坐標系統，一是頂點的位置（X，Y，Z）坐標，另一個就是UV坐標。

什麼是UV？簡單的說，就是貼圖影射到模型表面的依據。完整的說，其實應該是UVW（因為XYZ已經用過了，所以另選三個字母表示）。

U和V分別是圖片在顯示器水平、垂直方向上的坐標，取值一般都是0~1，也 就是（水平方向的第U個像素/圖片寬度，垂直方向的第V個像素/圖片高度）。

那W呢？貼圖是二維的，何來三個坐標？W的方向垂直於顯示器表面，一般 用於程序貼圖或者某些3D貼圖技術（記住，確實有三維貼圖這種概念！），對於遊戲而言不常用到，所以一般我們就簡稱UV了。

圖片文件都是二維方向上的平面。我們設水平方向是U，垂直方向是V，我們可以定位圖像上的任意一個像素。注意的是，(u,v)值範圍為[0,1]

UV就是將圖像上每一個點精確對應到模型物體的表面，在點與點之間的間隙位置進行圖像光滑插值處理，這就是所謂的UV貼圖。


對於NURBUS表面。因為具有UV參數，所以很容易通過換算把表面上的點和平面圖像上的像素對應起來。

# NURBUS?
有興趣可以了解一下貝茲曲線，樣條先再入手
<details>

[非均勻有理B樣條](https://www.youtube.com/watch?v=LgZctC4uM3Q&t=325s&ab_channel=%E5%9B%9E%E5%BD%A2%E9%92%88PaperClip)

三次方貝茲曲線的[[參數方程|參數]]形式：

$$
\mathbf{B}(t)=\mathbf{P}_0(1-t)^3+3\mathbf{P}_1t(1-t)^2+3\mathbf{P}_2t^2(1-t)+\mathbf{P}_3t^3, t \in [0,1]
$$

</details>

# 例子
假設我們知道在模型空間位置需要渲染的點為 (-2.3,7.1,88.2)，經過投影函數的變換之後，我們會獲得一個uv值 (u,v)，換算回來就是 (0.32,0.29) 紋理座標 (UV座標)

已知紋理的大小為 256 * 256，我們把uv座標相乘256，獲得 (81.92,74.24)，紋理採樣設置則決定了此紋理值rgba值 (可自定義)

![](pic/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202022-08-27%20002313.png)

# 通訊函數
使圖像可以平移，縮放，旋轉

# 紋理採樣
- 著色器中紋理通常以SamplerVariable（採樣變量）的形式存在，它是一種uniform型變量，在處理不同片元時，它是已知不變的；
- 一個Sample與一個Texture對應，是一種特殊變量。如果是二維紋理時，則為Sampler2D；

# 紋理採樣設置: Wrap Mode
決定UV值在[0,1]以外的表現
- OpenGL --- "包裝模式" (Wrapping Model)
- DirectX --- "紋理尋址模式" (Texture Addressing Mode)
- Repeat Mirror Clamp Broder
![](pic/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202022-08-27%20010845.png)

# 紋理採樣設置: Filter Mode (過濾設置)
決定了當紋理由於變化而產生拉伸的時候，要採用哪一種濾波模式來調整它的表現

- 雙線性插值
- 立方卷積插值
- Qu‘ilez的光滑曲線插值

![](pic/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202022-08-27%20012145.png)

# 提高內容
1. 雙線性插值: 詳細推導過程
2. 紋理採樣 (過濾設置)
<details>

首先在 ''x'' 方向進行線性插值，得到

$$
\begin{align}
f(x, y_1) &\approx \frac{x_2-x}{x_2-x_1} f(Q_{11}) + \frac{x-x_1}{x_2-x_1} f(Q_{21}), \\
f(x, y_2) &\approx \frac{x_2-x}{x_2-x_1} f(Q_{12}) + \frac{x-x_1}{x_2-x_1} f(Q_{22}).
\end{align}
$$

然後在 ''y'' 方向進行線性插值，得到

$$
\begin{align}
f(x,y) &\approx \frac{y_2-y}{y_2-y_1} f(x, y_1) + \frac{y-y_1}{y_2-y_1} f(x, y_2) \\
&= \frac{y_2-y}{y_2-y_1} \left ( \frac{x_2-x}{x_2-x_1} f(Q_{11}) + \frac{x-x_1}{x_2-x_1} f(Q_{21}) \right ) + \frac{y-y_1}{y_2-y_1} \left ( \frac{x_2-x}{x_2-x_1} f(Q_{12}) + \frac{x-x_1}{x_2-x_1} f(Q_{22}) \right ) \\
&= \frac{1}{(x_2-x_1)(y_2-y_1)} \big( f(Q_{11})(x_2-x)(y_2-y) + f(Q_{21})(x-x_1)(y_2-y)+  f(Q_{12})(x_2-x)(y-y_1) + f(Q_{22})(x-x_1)(y-y_1) \big)\\
&=\frac{1}{(x_2-x_1)(y_2-y_1)}  \begin{bmatrix} x_2-x & x-x_1 \end{bmatrix} \begin{bmatrix} f(Q_{11}) & f(Q_{12}) \\ f(Q_{21})& f(Q_{22}) \end{bmatrix} \begin{bmatrix}
y_2-y \\ y-y_1 \end{bmatrix}.
\end{align}
$$

注意此處如果先在 ''y'' 方向插值、再在 ''x'' 方向插值，其結果與按照上述順序雙線性插值的結果是一樣的。

### 例子
已知: 點P(u,v) = (81.92,74.24)
1. 點P(u,v) 減去 像素中心 (0.5,0.5) = (81.42,73.74)
2. 取得最接近的四個屏幕像素點範圍: (81,73) ~ (82,74)
3. 相對於該四個像素中心形成的座標系位置 (u,v) = (0.42,0.74)

$$ 
f(x,y) \approx \begin{bmatrix}
1-x & x \end{bmatrix} \begin{bmatrix}
f(0,0) & f(0,1) \\
f(1,0) & f(1,1) \end{bmatrix} \begin{bmatrix}
1-y \\
y \end{bmatrix}
$$

插值顏色= $$ (1-0.42)×(1-0.74)t(x,y)+0.42(1-0.74)×t(x+1,y)+(1-0.42)0.74t(x,y+1)+0.42×0.74×t(x+1,y+1) $$

## 立方卷積插值 和 Qu‘ilez的光滑曲線插值
~~自己上網找找看看~~

## Mipmapping
在C++ DirectX中 LV201-Mipmapping 可以學習

## Anisotropic Filtering 各向異性過濾
在C++ DirectX中 LV201-Anisotropic Filtering 可以學習

## 積分圖 summed area table
以內存為代價，更加有效地計算紋理值。例如將數組中的R8G8B8A8 轉成 R16G16B16A16，再代入公式

</details>

# 紋理的優化和應用
CPU渲染優化的方式：
- 紋理圖集 (將多張紋理合併到一張紋理中，降低頻繁改變紋理所帶來的消耗)
- 紋理數組
- 無約束紋理
- 紋理壓縮：減小紋理的體積

![紋理圖集](pic/RaiQ5.png)

# DrawCall
為使CPU和GPU並行工作，存在一個命令緩衝區來存儲命令隊列。 CPU向其中添加命令，GPU從其中讀取命令。 DrawCall是命令的一種。如果DrawCall過多，則CPU將花費大量時間在提交DrawCall上。

# 其他常見紋理
- 立方體紋理（CubeMap）：使用六張貼圖形成以原點為中心的立方體。採樣時使用方向向量，從原點出發的方向向量與立方體相交的位置即為採樣點。一般應用於環境貼圖。

- 凹凸貼圖（BumpMap）：在不增加頂點、不移動頂點的情況下，改變模型法線，產生凹凸效果。

- 位移貼圖（Displacement Mapping）：將頂點進行移動，產生凹凸效果。這要求模型表面有足夠多的頂點供使用。 DirectX提供了一種動態進行曲面細分的方法，使得在模型本身頂點數量較少的情況下，仍能正確使用位移貼圖。

# 備忘錄
Unreal Engine 5 自定義UV
https://docs.unrealengine.com/5.0/zh-CN/customized-uvs-in-unreal-engine-materials/

